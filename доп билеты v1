Билет 1

    Теория: Объясните разницу между передачей параметров по значению, по ссылке и по указателю в C++. В каких сценариях предпочтительнее каждый из способов? Что такое const-корректность и как она влияет на выбор способа передачи?

    Теория: Опишите жизненный цикл объекта в C++ (создание, копирование, перемещение, уничтожение). Что такое "правило пяти/трех/нуля"? Приведите пример класса, где это правило необходимо применить.

    Практика: Реализуйте класс ThreadSafeStack<T> — потокобезопасный стек на основе std::stack. Должны поддерживаться операции push, pop, top, empty. Используйте механизмы синхронизации из стандартной библиотеки (std::mutex, std::lock_guard). Продумайте проблему "гонки данных" между top и pop.

Билет 2

    Теория: Что такое "умные указатели" в современном C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)? Опишите семантику владения для каждого. В чем ключевое отличие std::make_unique/std::make_shared от прямого использования new?

    Теория: Какие проблемы решает использование пространств имен (namespaces) в C++ проекте? Как правильно организовать включение заголовочных файлов (.hpp/.h) и реализацию (.cpp) в многофайловом проекте? Что такое include guards и зачем они нужны?

    Практика: Реализуйте функцию merge_sorted_containers, которая принимает два контейнера (std::vector<int>), отсортированные по возрастанию, и возвращает новый std::vector<int>, содержащий все элементы обоих контейнеров, также отсортированные. Напишите шаблонную версию функции, которая может работать с разными типами данных, поддерживающими сравнение.

Билет 3

    Теория: Объясните принципы ООП: инкапсуляция, наследование, полиморфизм. Как они реализуются в C++? Что такое абстрактный класс и чисто виртуальная функция? Приведите пример иерархии классов, где их использование оправдано.

    Теория: Что такое move-семантика и rvalue-ссылки в C++11 и новее? Как они позволяют избегать лишних копирований? Что такое "универсальная ссылка" (universal reference) и "совершенная передача" (perfect forwarding)?

    Практика: Спроектируйте и реализуйте простую иерархию классов для представления геометрических фигур (Shape). Создайте абстрактный базовый класс Shape с виртуальными методами area() и perimeter(). Реализуйте производные классы Rectangle и Circle. Создайте std::vector<Shape*>, добавьте в него различные фигуры и вычислите их суммарную площадь.

Билет 4

    Теория: Опишите модель памяти в C++ (стек, куча, статическая память). Как распределяется память для локальных переменных, динамических объектов, глобальных и статических переменных? Каковы обязанности программиста по управлению памятью в каждом случае?

    Теория: Что такое шаблоны (templates) в C++? В чем разница между шаблоном функции и шаблоном класса? Что такое специализация шаблона и когда она применяется?

    Практика: Реализуйте простой класс-обертку для работы с базой данных SQLite (можно использовать стандартный C-интерфейс или условный заглушечный класс). Класс Database должен уметь: открывать/закрывать соединение, выполнять запросы без возврата результата (execute) и запросы с возвратом набора строк (query). Сосредоточьтесь на RAII-идиоме для управления ресурсом соединения.

Билет 5

    Теория: Что такое RAII (Resource Acquisition Is Initialization)? Как эта идиома связана с обработкой исключений и управлением ресурсами (память, файлы, мьютексы) в C++? Приведите примеры из стандартной библиотеки.

    Теория: Опишите механизм обработки исключений в C++ (try, catch, throw). Какие типы обычно используют для исключений? Что не рекомендуется делать внутри блока catch? Как избежать утечек ресурсов при возникновении исключения?

    Практика: Реализуйте класс Buffer, представляющий собой динамический массив данных. Класс должен управлять памятью по правилу пяти (предусмотреть конструктор копирования, перемещения, операторы присваивания, деструктор). Добавьте методы для доступа к элементам, изменения размера и итерации.

Билет 6

    Теория: Чем компиляция отличается от линковки? Опишите процесс сборки C++ проекта в Visual Studio или с помощью утилиты make/CMake. Что такое объектный файл, библиотека (статическая/динамическая)?

    Теория: Что такое std::future, std::promise и std::async? Как они упрощают асинхронные вычисления по сравнению с прямым созданием потоков (std::thread)?

    Практика: Реализуйте программу, которая параллельно вычисляет сумму элементов двух больших векторов. Разделите векторы на несколько частей (по количеству ядер процессора), создайте потоки для вычисления частичных сумм, а затем соберите итоговый результат. Используйте std::thread и std::accumulate или вручную напишите цикл.

Билет 7

    Теория: Что такое контейнеры и итераторы в STL? Классифицируйте основные контейнеры (последовательные, ассоциативные, неупорядоченные). В чем разница между std::vector, std::list и std::deque с точки зрения внутреннего устройства и сложности операций вставки/доступа?

    Теория: Объясните разницу между struct и class в C++. Как выбрать между ними? Что такое "POD-тип" (Plain Old Data) и зачем это понятие было важно в более ранних стандартах?

    Практика: Реализуйте систему сериализации пользовательских типов данных в JSON-подобный формат. Создайте шаблонную функцию serialize, которая для арифметических типов, std::string и std::vector выводит их представление в std::ostream. Попробуйте использовать перегрузку функций или специализацию шаблонов.

Билет 8

    Теория: Что такое лямбда-выражения в C++? Из каких частей они состоят (список захвата, параметры, тело, возвращаемый тип)? Как работает захват переменных из окружающей области видимости (по значению, по ссылке)?

    Теория: Как в C++ реализуется полиморфизм "во время выполнения" (dynamic polymorphism)? Что такое таблица виртуальных функций (vtable) и указатель на нее (vptr)? Опишите этот механизм на низком уровне.

    Практика: Создайте класс Observable, реализующий паттерн "Наблюдатель" (Observer). Класс должен позволять подписываться другим объектам (с функтором std::function) на уведомления. Реализуйте метод notify для рассылки сообщений всем подписчикам. Протестируйте на примере простой модели (например, Sensor -> Display).
