# Лабораторная работа: Многопоточность и асинхронное программирование в C++

## Цель работы
Закрепить практические навыки работы с потоками, синхронизацией и асинхронным программированием в C++.

## Теоретическая часть

### Основные понятия:
- Поток - независимая последовательность выполнения инструкций
- Мьютекс - механизм синхронизации для защиты общих данных
- Асинхронность - выполнение задач без блокировки основного потока
- Гонка данных - ситуация, когда несколько потоков одновременно обращаются к общим данным

## Практические задания

### Задание 1: Базовые потоки и синхронизация

Цель: Научиться создавать потоки и использовать мьютексы для синхронизации.

Задача: Реализовать программу, которая создает несколько потоков для параллельного вычисления суммы элементов большого вектора. Сравнить производительность однопоточного и многопоточного подходов.

Требования:
1. Создать вектор из 10 000 000 случайных чисел от 1 до 100
2. Реализовать однопоточное вычисление суммы
3. Реализовать многопоточное вычисление суммы с использованием 4 потоков
4. Замерить время выполнения обоих подходов
5. Использовать std::mutex для защиты общей суммы

Шаблон для реализации:
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <chrono>
#include <random>

class VectorSumCalculator {
private:
    std::vector<int> data;
    std::mutex sum_mutex;
    
public:
    VectorSumCalculator(size_t size) {
        // TODO: Заполнить вектор случайными числами
    }
    
    // Однопоточное вычисление суммы
    long long calculateSingleThreaded() {
        // TODO: Реализовать однопоточное вычисление
    }
    
    // Многопоточное вычисление суммы
    long long calculateMultiThreaded(int num_threads) {
        // TODO: Реализовать многопоточное вычисление
        // Разделить вектор на части, создать потоки,
        // использовать мьютекс для защиты общей суммы
    }
};

int main() {
    // TODO: Создать объект, выполнить оба расчета,
    // замерить время и сравнить результаты
}### Задание 2: Производитель-Потребитель с condition_variable

Цель: Освоить работу с условными переменными для координации потоков.

Задача: Реализовать систему "Производитель-Потребитель" с использованием std::condition_variable.

Требования:
1. Создать класс ThreadSafeQueue с методами push() и pop()
2. Реализовать один поток-производитель, который генерирует числа
3. Реализовать три потока-потребителя, которые обрабатывают числа
4. Использовать std::condition_variable для эффективного ожидания
5. Обеспечить корректное завершение всех потоков

Шаблон для реализации:
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue;
    std::mutex mutex;
    std::condition_variable cond;
    bool shutdown = false;
    
public:
    void push(T value) {
        // TODO: Реализовать потокобезопасное добавление
    }
    
    bool pop(T& value) {
        // TODO: Реализовать потокобезопасное извлечение
        // Возвращать false если очередь закрыта и пуста
    }
    
    void shutdown() {
        // TODO: Реализовать корректное закрытие очереди
    }
};

void producer(ThreadSafeQueue<int>& queue, int count) {
    // TODO: Генерировать числа и помещать в очередь
}

void consumer(ThreadSafeQueue<int>& queue, int id) {
    // TODO: Извлекать и обрабатывать числа из очереди
}### Задание 3: Параллельная обработка изображений

Цель: Научиться применять многопоточность для обработки данных.

Задача: Реализовать параллельное применение фильтра к "изображению" (матрице).

Требования:
1. Представить изображение как матрицу чисел (яркостей пикселей)
2. Реализовать фильтр размытия (усреднение соседних пикселей)
3. Разделить изображение на горизонтальные полосы для обработки в разных потоках
4. Собрать результаты и вывести статистику

Шаблон для реализации:
`cpp
#include <vector>
#include <thread>
#include <algorithm>
class ImageProcessor {
private:
    std::vector<std::vector<int>> image;
    int width, height;
    
public:
    ImageProcessor(int w, int h) : width(w), height(h) {
        // TODO: Инициализировать "изображение" случайными значениями
    }
    
    // Однопоточное применение фильтра
    void applyFilterSingleThread() {
        // TODO: Реализовать последовательное применение фильтра
    }
    
    // Многопоточное применение фильтра
    void applyFilterMultiThread(int num_threads) {
        // TODO: Разделить изображение на части,
        // создать потоки для обработки каждой части
    }
    
    // Фильтр размытия (усреднение 3x3)
    int blurPixel(int x, int y) {
        // TODO: Реализовать фильтр усреднения
    }
};
### Задание 4: Асинхронные вычисления с std::async

**Цель:** Освоить асинхронное программирование с `std::async` и `std::future`.

**Задача:** Реализовать параллельное вычисление числа π с использованием метода Монте-Карло.

**Требования:**
1. Использовать метод Монте-Карло для вычисления π
2. Разделить вычисления на несколько асинхронных задач
3. Использовать `std::async` с политикой `std::launch::async`
4. Собрать результаты с помощью `std::future`
5. Обработать возможные исключения

**Шаблон для реализации:**cpp
#include <future>
#include <random>
#include <vector>

class PiCalculator {
public:
    // Вычисление π с использованием заданного количества точек
    double calculatePiPortion(int total_points) {
        // TODO: Реализовать метод Монте-Карло для части вычислений
    }
    
    // Параллельное вычисление π
    double calculatePiParallel(int total_points, int num_tasks) {
        std::vector<std::future<double>> futures;
        int points_per_task = total_points / num_tasks;
        
        // TODO: Создать асинхронные задачи
        // TODO: Собрать и усреднить результаты
        
        return 0.0; // Заглушка
    }
};
### Задание 5: Пул потоков с задачами

**Цель:** Реализовать простой пул потоков для выполнения задач.

**Задача:** Создать класс `ThreadPool`, который управляет пулом рабочих потоков.

**Требования:**
1. Реализовать класс `ThreadPool` с фиксированным количеством потоков
2. Добавить метод `submit()` для добавления задач
3. Использовать `std::packaged_task` для возврата результатов
4. Реализовать корректное завершение пула
5. Продемонстрировать работу на примере вычисления факториалов

**Шаблон для реализации:**cpp
#include <thread>
#include <vector>
#include <queue>
#include <future>
#include <functional>

class ThreadPool {
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop = false;
    
public:
    ThreadPool(size_t num_threads) {
        // TODO: Создать рабочие потоки
    }
    
    template<class F, class... Args>
    auto submit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
        // TODO: Добавить задачу в очередь и вернуть future
    }
    
    ~ThreadPool() {
        // TODO: Реализовать корректное завершение
    }
};

// Функция для демонстрации - вычисление факториала
unsigned long long factorial(int n) {
    // TODO: Реализовать вычисление факториала
}
`
## Дополнительные требования

1. Компиляция: Программа должна компилироваться без ошибок
2. Отсутствие утечек: Не должно быть утечек памяти или ресурсов
3. Документация: Код должен быть хорошо прокомментирован
4. Тестирование: Предоставить примеры работы всех функций

## Рекомендации по выполнению

1. Начинайте с простых тестовых примеров
2. Используйте отладчик для поиска проблем синхронизации
3. Тестируйте на разных размерах данных
4. Проверяйте корректность результатов однопоточными версиями
5. Убедитесь в отсутствии гонок данных с помощью sanitizers

## Пример запуска и тестирования

// Пример тестовой программы
int main() {
    // Тестирование задания 1
    VectorSumCalculator calculator(10000000);
    auto single_result = calculator.calculateSingleThreaded();
    auto multi_result = calculator.calculateMultiThreaded(4);
    
    std::cout << "Single-threaded result: " << single_result << std::endl;
    std::cout << "Multi-threaded result: " << multi_result << std::endl;
    
    // Тестирование других заданий...
    
    return 0;
}Удачи в выполнении лабораторной работы!
