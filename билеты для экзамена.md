Билет 1

    Теория: В чем разница между передачей параметров в функцию по значению, по ссылке и по указателю? Приведите примеры. Когда нужно использовать const при передаче по ссылке?

    Теория: Что такое конструктор и деструктор класса? Для чего они нужны? Что такое конструктор копирования и когда он вызывается?

    Практика: Напишите класс Student, который хранит имя (строку) и оценку (целое число). Реализуйте конструктор, методы для получения и изменения данных, метод print() для вывода информации. В main() создайте несколько объектов и продемонстрируйте работу методов.

Билет 2

    Теория: Объясните понятия "указатель" и "ссылка" в C++. В чем их сходство и ключевые отличия? Можно ли создать ссылку, которая не указывает ни на какой объект?

    Теория: Что такое перегрузка функций и операторов? Приведите пример перегрузки функции и пример перегрузки оператора + для простого класса.

    Практика: Реализуйте класс Array, который внутри использует обычный массив int. Класс должен уметь: создаваться с заданным размером, позволять получить размер, изменять и получать значение по индексу (с проверкой границ). Реализуйте деструктор для освобождения памяти.

Билет 3

    Теория: Опишите три основных принципа ООП: инкапсуляция, наследование, полиморфизм. Дайте краткое определение каждому.

    Теория: Что такое виртуальные функции в C++? Зачем нужен ключевой слово virtual? Что такое чисто виртуальная функция и абстрактный класс?

    Практика: Создайте базовый класс Animal с виртуальным методом makeSound(). Создайте два производных класса Dog и Cat, которые переопределяют этот метод. В main() создайте массив указателей типа Animal* на объекты Dog и Cat и вызовите makeSound() для каждого.

Билет 4

    Теория: Как динамически выделить и освободить память для одного объекта и для массива объектов в C++? Чем new/delete отличаются от malloc()/free()?

    Теория: Что такое шаблоны (templates) в C++? Приведите пример шаблонной функции для поиска максимума из двух значений.

    Практика: Напишите шаблонную функцию swap, которая меняет местами значения двух переменных любого типа. Продемонстрируйте ее работу с типами int, double и std::string.

Билет 5

    Теория: Что такое std::vector и std::string? Чем они лучше обычных массивов и строк в стиле C (char[])? Приведите основные операции с ними.

    Теория: Объясните, зачем нужны пространства имен (namespace). Как обратиться к имени из другого пространства имен?

    Практика: Напишите программу, которая считывает из файла input.txt список чисел (по одному в строке), сохраняет их в std::vector<int>, находит минимальное и максимальное значение и записывает результат в файл output.txt.

Билет 6

    Теория: Что такое исключения (try, catch, throw)? Для чего они используются? Как создать собственный класс исключения?

    Теория: Опишите жизненный цикл объекта в C++: когда вызываются конструкторы, деструкторы, конструктор копирования.

    Практика: Создайте класс BankAccount, который хранит номер счета и баланс. Реализуйте методы для внесения и снятия денег. При снятии денег выбрасывайте исключение InsufficientFundsException (создайте этот класс), если запрашиваемая сумма превышает баланс. В main() обработайте это исключение.

Билет 7

    Теория: Что такое "правило трех" в C++? В каких классах его необходимо реализовать и почему?

    Теория: Что такое static члены класса (переменные и методы)? Как к ним обратиться и в чем их особенность?

    Практика: Реализуйте класс Counter, который подсчитывает количество созданных объектов этого класса. Используйте static переменную-член. Добавьте static метод getCount() для получения текущего количества.

Билет 8

    Теория: Что такое дружественные функции (friend) и классы? В каких ситуациях их использование может быть оправданно?

    Теория: Какие виды наследования вы знаете (public, protected, private)? Чем отличается public наследование от остальных?

    Практика: Создайте класс Point для представления точки на плоскости (x, y). Перегрузите операторы == (равенство точек) и + (сложение точек как векторов) как дружественные функции. Продемонстрируйте их работу.

Билет 9

    Теория: Что такое итераторы? Для чего они нужны и как используются с контейнерами STL, например, с std::vector?

    Теория: Объясните разницу между композицией ("has-a") и наследованием ("is-a") при проектировании классов. Приведите примеры.

    Практика: Создайте класс Library, который содержит std::vector объектов класса Book (сам класс Book должен содержать название и автора). Реализуйте методы для добавления книги, удаления книги по названию и вывода всего списка книг.

Билет 10

    Теория: Что такое умные указатели std::unique_ptr и std::shared_ptr? Какую основную проблему они решают?

    Теория: Что такое const методы класса? Зачем они нужны и как объявляются?

    Практика: Напишите класс Matrix для работы с двумерной матрицей целых чисел фиксированного размера (например, 3x3). Реализуйте методы для сложения двух матриц и умножения матрицы на число. Используйте перегрузку операторов + и *.

Билет 11

    Теория: Что такое inline-функции? В чем их преимущество и потенциальный недостаток по сравнению с обычными функциями?

    Теория: Что такое this указатель? Когда он неявно передается в методы класса и для чего используется?

    Практика: Создайте класс Rectangle с приватными полями width и height. Реализуйте методы для вычисления площади и периметра. Перегрузите оператор > (больше), чтобы сравнивать прямоугольники по площади.

Билет 12

    Теория: Что такое список инициализации в конструкторе? Зачем он нужен и чем отличается от присваивания значений внутри тела конструктора?

    Теория: Что такое mutable спецификатор? В каких редких случаях его применение оправданно?

    Практика: Реализуйте класс Circle с приватным полем radius. Создайте конструктор с списком инициализации. Добавьте const методы для получения радиуса и вычисления площади. Напишите функцию printCircle, которая принимает const Circle&.

Билет 13

    Теория: В чем разница между агрегацией и композицией? Приведите примеры из реального мира.

    Теория: Что такое анонимные (безымянные) объекты? Где они могут быть полезны?

    Практика: Создайте класс Date с полями: день, месяц, год. Реализуйте метод isValid(), который проверяет корректность даты (учтите високосные годы). Добавьте метод toString(), возвращающий дату в формате "ДД.ММ.ГГГГ".

Билет 14

    Теория: Что такое перечисляемый тип enum? Чем enum class (строго типизированное перечисление) лучше обычного enum?

    Теория: Что такое typedef и using для создания псевдонимов типов? Какой вариант предпочтительнее в современном C++?

    Практика: Создайте enum class Season { Winter, Spring, Summer, Autumn }. Напишите функцию getSeasonName, которая принимает Season и возвращает соответствующую строку ("Зима", "Весна" и т.д.). Продемонстрируйте ее работу.

Билет 15

    Теория: Что такое assert и для чего он используется? Чем отличается от обработки исключений?

    Теория: Что такое nullptr в C++11? Почему его использование предпочтительнее NULL или 0?

    Практика: Реализуйте функцию int* findMax(int* array, int size), которая возвращает указатель на максимальный элемент в массиве. Если массив пустой, функция должна возвращать nullptr. В main() протестируйте оба случая.

Билет 16

    Теория: Что такое перегрузка операторов ввода >> и вывода <<? Почему их обычно перегружают как дружественные функции?

    Теория: Что такое std::pair? В каких ситуациях удобно использовать этот шаблонный класс?

    Практика: Создайте класс Fraction (дробь) с полями numerator (числитель) и denominator (знаменатель). Реализуйте конструктор, который упрощает дробь (например, 2/4 -> 1/2). Перегрузите операторы + для сложения дробей и << для вывода в формате "a/b".

Билет 17

    Теория: Что такое std::array? Чем он лучше обычного статического массива в стиле C?

    Теория: Что такое область видимости переменных? Опишите локальную, глобальную и область видимости класса.

    Практика: Создайте шаблонную функцию countOccurrences, которая принимает std::vector<T> и значение T, и возвращает количество раз, которое это значение встречается в векторе. Протестируйте для int и std::string.

Билет 18

    Теория: Что такое "срезка объекта" (object slicing)? Когда она происходит и как ее избежать?

    Теория: Что такое auto в современном C++? В каких случаях его использование улучшает читаемость кода, а в каких - ухудшает?

    Практика: Создайте иерархию: базовый класс Employee (сотрудник) с виртуальным методом calculateSalary(), и производные классы HourlyEmployee (почасовая оплата) и SalariedEmployee (фиксированная зарплата). Создайте вектор std::vector<Employee*> и посчитайте общую зарплату всех сотрудников.

Билет 19

    Теория: Что такое dynamic_cast? Для чего он используется и в чем его отличие от static_cast?

    Теория: Что такое #pragma once? Какой традиционной конструкции он эквивалентен и зачем это нужно?

    Практика: Создайте базовый класс Device и производные Printer и Scanner. Добавьте в Device виртуальный метод getType(). В main() создайте массив разных устройств и используйте dynamic_cast для безопасного вызова специфического метода printDocument() только у объектов типа Printer.

Билет 20

    Теория: Что такое volatile переменная? В каких специфических ситуациях (не связанных с многопоточностью) она может понадобиться?

    Теория: Что такое std::map? Как организован доступ к элементам? Приведите пример использования.

    Практика: Реализуйте простой англо-русский словарь с использованием std::map<std::string, std::string>. Напишите функции для добавления пар слов, поиска перевода и вывода всего словаря.

Билет 21

    Теория: Что такое std::list? В каких случаях его использование предпочтительнее std::vector?

    Теория: Что такое "глубокое" и "поверхностное" копирование? Какое из них реализует конструктор копирования по умолчанию?

    Практика: Создайте класс String (упрощенная версия std::string), который хранит строку в динамическом массиве char*. Реализуйте конструктор, конструктор копирования (глубокое копирование), оператор присваивания и деструктор (правило трех).

Билет 22

    Теория: Что такое статические локальные переменные внутри функции? Чем они отличаются от обычных локальных переменных?

    Теория: Что такое std::function? Какой проблемой он занимается и когда его удобно использовать?

    Практика: Напишите функцию applyToVector, которая принимает std::vector<int> и функцию (или лямбду), и применяет эту функцию к каждому элементу вектора, изменяя его. Протестируйте, передав лямбды для увеличения на 1 и для умножения на 2.

Билет 23

    Теория: Что такое std::set? Какое основное свойство элементов в std::set и как это достигается?

    Теория: Что такое идиома pImpl (Pointer to Implementation)? Какую проблему инкапсуляции она решает?

    Практика: Создайте класс UniqueNumbers, который хранит коллекцию уникальных целых чисел с использованием std::set. Реализуйте методы для добавления числа, проверки наличия числа и вывода всех чисел в отсортированном порядке.

Билет 24

    Теория: Что такое friend класс? В каких редких случаях дружественный класс может быть полезен?

    Теория: Что такое std::stack и std::queue? Какие основные операции они поддерживают?

    Практика: Напишите программу, которая проверяет корректность расстановки скобок (, ), [, ], {, } в строке с использованием std::stack. Алгоритм: открывающие скобки кладем в стек, встретив закрывающую - проверяем вершину стека.

Билет 25

    Теория: Что такое std::deque? Как он устроен "под капотом" и в чем его преимущества перед std::vector?

    Теория: Что такое "умные указатели" и почему std::auto_ptr считается устаревшим и опасным?

    Практика: Реализуйте класс FileHandler, который в конструкторе открывает файл (использует std::fstream), а в деструкторе закрывает его (RAII). Добавьте метод для чтения всего содержимого файла в строку.

Билет 26

    Теория: Что такое "поток данных" (std::istream, std::ostream)? Как связаны std::cout, std::cin и эти классы?

    Теория: Что такое explicit конструктор? Зачем запрещать неявное преобразование типов?

    Практика: Создайте класс Complex для работы с комплексными числами. Перегрузите операторы +, -, * (умножение) и <<. Сделайте конструктор от двух double explicit.

Билет 27

    Теория: Что такое std::vector::reserve() и std::vector::capacity()? Зачем управлять емкостью вектора?

    Теория: Что такое "делегирующий конструктор" (C++11)? Как помогает избежать дублирования кода?

    Практика: Напишите класс Statistics, который принимает последовательность чисел (через std::vector или при добавлении по одному) и вычисляет основные статистики: среднее, минимум, максимум. Используйте делегирующие конструкторы.

Билет 28

    Теория: Что такое std::move семантика? (Объясните на простом уровне, без углубления в rvalue-ссылки).

    Теория: Что такое "полиморфизм времени компиляции" и чем он отличается от "полиморфизма времени выполнения"?

    Практика: Создайте шаблонный класс Box, который может хранить один элемент любого типа T. Реализуйте методы put (положить значение), get (получить значение) и isEmpty (проверить, пуст ли бокс).

Билет 29

    Теория: Что такое "аллокатор памяти"? (Объясните концептуально, без деталей реализации).

    Теория: Что такое noexcept спецификатор? Когда его стоит использовать?

    Практика: Реализуйте функцию splitString, которая принимает строку std::string и символ-разделитель, и возвращает std::vector<std::string> — подстроки между разделителями.

Билет 30

    Теория: Что такое "множественное наследование"? Какая главная проблема возникает при его использовании ("ромбовидное" наследование)?

    Теория: Что такое "анонимное пространство имен" (namespace { ... })? Чем оно заменяет в современном C++?

    Практика: Создайте интерфейсный класс Drawable с чисто виртуальным методом draw(). Создайте классы Circle и Square, реализующие этот интерфейс. В main() создайте std::vector<Drawable*> и вызовите draw() для всех объектов.
