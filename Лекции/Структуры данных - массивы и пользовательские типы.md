# Лекция по C++: Структуры данных - массивы и пользовательские типы

## 1. Введение в структуры данных

**Структуры данных** - это способы организации и хранения данных в памяти компьютера для эффективного доступа и модификации.

```cpp
#include <iostream>
using namespace std;

int main() {
    // Простейшая структура данных - переменная
    int number = 10;  // Хранит одно целое число
    
    // Но что если нам нужно хранить много связанных данных?
    // Для этого используются более сложные структуры данных
    return 0;
}
```

## 2. Массивы - фундаментальная структура данных

### 2.1. Что такое массив?

**Массив** - это коллекция элементов одного типа, расположенных в памяти последовательно.

```cpp
#include <iostream>
using namespace std;

int main() {
    // Объявление массива из 5 целых чисел
    int numbers[5];  // В памяти выделяется блок на 5 последовательных ячеек
    
    // Инициализация массива
    int scores[5] = {85, 92, 78, 90, 88};
    
    // Можно не указывать размер, если инициализируем при объявлении
    int temperatures[] = {25, 28, 30, 22, 26, 24};
    
    return 0;
}
```

**Важный момент**: Индексация массивов начинается с 0!

### 2.2. Доступ к элементам массива

```cpp
#include <iostream>
using namespace std;

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    
    // Обращение к элементам по индексу
    cout << "Первый элемент: " << numbers[0] << endl;  // 10
    cout << "Третий элемент: " << numbers[2] << endl;  // 30
    
    // Изменение элементов
    numbers[1] = 25;  // Теперь массив: {10, 25, 30, 40, 50}
    
    // ОПАСНО: выход за границы массива!
    // numbers[5] = 60;  // Неопределенное поведение!
    // numbers[-1] = 5;  // Неопределенное поведение!
    
    return 0;
}
```

### 2.3. Многомерные массивы

```cpp
#include <iostream>
using namespace std;

int main() {
    // Двумерный массив (матрица) 3x3
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    // Доступ к элементам
    cout << "matrix[1][2] = " << matrix[1][2] << endl;  // 6
    
    // Трехмерный массив
    int cube[2][2][2] = {
        {{1, 2}, {3, 4}},
        {{5, 6}, {7, 8}}
    };
    
    return 0;
}
```

### 2.4. Работа с массивами в функциях

```cpp
#include <iostream>
using namespace std;

// Функция для вывода массива
// Массив передается как указатель на первый элемент
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Функция для изменения массива
void doubleArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;  // Изменения сохраняются в исходном массиве!
    }
}

int main() {
    int myArray[5] = {1, 2, 3, 4, 5};
    
    cout << "Исходный массив: ";
    printArray(myArray, 5);
    
    doubleArray(myArray, 5);
    
    cout << "Удвоенный массив: ";
    printArray(myArray, 5);
    
    return 0;
}
```

**Важно**: При передаче массива в функцию передается указатель на первый элемент, поэтому изменения в функции влияют на исходный массив.

## 3. Пользовательские типы данных

### 3.1. Структуры (struct)

**Структура** - это пользовательский тип данных, который объединяет несколько переменных разных типов.

```cpp
#include <iostream>
#include <string>
using namespace std;

// Объявление структуры
struct Student {
    string name;        // Строка - имя студента
    int age;           // Целое число - возраст
    double gpa;        // Дробное число - средний балл
    bool isActive;     // Логическое значение - активен ли студент
};  // Не забудьте точку с запятой!

int main() {
    // Создание переменной типа Student
    Student student1;
    
    // Инициализация полей структуры
    student1.name = "Иван Петров";
    student1.age = 20;
    student1.gpa = 4.5;
    student1.isActive = true;
    
    // Вывод информации о студенте
    cout << "Имя: " << student1.name << endl;
    cout << "Возраст: " << student1.age << endl;
    cout << "Средний балл: " << student1.gpa << endl;
    cout << "Активен: " << (student1.isActive ? "Да" : "Нет") << endl;
    
    return 0;
}
```

### 3.2. Инициализация структур

```cpp
#include <iostream>
using namespace std;

struct Point {
    int x;
    int y;
};

struct Rectangle {
    Point topLeft;     // Вложенная структура
    Point bottomRight;
};

int main() {
    // Различные способы инициализации структур
    
    // 1. Поэлементная инициализация
    Point p1;
    p1.x = 10;
    p1.y = 20;
    
    // 2. Инициализация при создании
    Point p2 = {30, 40};
    
    // 3. Uniform initialization (C++11)
    Point p3{50, 60};
    
    // 4. Инициализация вложенных структур
    Rectangle rect = {{0, 0}, {100, 100}};
    
    cout << "Прямоугольник от (" << rect.topLeft.x << ", " << rect.topLeft.y 
         << ") до (" << rect.bottomRight.x << ", " << rect.bottomRight.y << ")" << endl;
    
    return 0;
}
```

### 3.3. Массивы структур

```cpp
#include <iostream>
using namespace std;

struct Book {
    string title;
    string author;
    int year;
    double price;
};

int main() {
    // Массив структур
    Book library[3] = {
        {"Война и мир", "Лев Толстой", 1869, 15.99},
        {"Преступление и наказание", "Федор Достоевский", 1866, 12.50},
        {"Мастер и Маргарита", "Михаил Булгаков", 1967, 14.75}
    };
    
    // Вывод информации о книгах
    for (int i = 0; i < 3; i++) {
        cout << "Книга " << i + 1 << ":" << endl;
        cout << "  Название: " << library[i].title << endl;
        cout << "  Автор: " << library[i].author << endl;
        cout << "  Год: " << library[i].year << endl;
        cout << "  Цена: $" << library[i].price << endl;
        cout << endl;
    }
    
    return 0;
}
```

### 3.4. Функции и структуры

```cpp
#include <iostream>
#include <cmath>
using namespace std;

struct Point {
    double x;
    double y;
};

// Функция для вычисления расстояния между двумя точками
double distance(Point p1, Point p2) {
    return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));
}

// Функция для вывода точки
void printPoint(Point p) {
    cout << "(" << p.x << ", " << p.y << ")";
}

// Функция, возвращающая структуру
Point createPoint(double x, double y) {
    Point p;
    p.x = x;
    p.y = y;
    return p;
}

int main() {
    Point a = {0, 0};
    Point b = {3, 4};
    
    cout << "Расстояние между ";
    printPoint(a);
    cout << " и ";
    printPoint(b);
    cout << " = " << distance(a, b) << endl;
    
    Point c = createPoint(5, 12);
    cout << "Создана точка: ";
    printPoint(c);
    cout << endl;
    
    return 0;
}
```

## 4. Перечисления (enum)

**Перечисление** - это пользовательский тип, который состоит из набора именованных констант.

```cpp
#include <iostream>
using namespace std;

// Объявление перечисления
enum Day {
    MONDAY,     // 0
    TUESDAY,    // 1
    WEDNESDAY,  // 2
    THURSDAY,   // 3
    FRIDAY,     // 4
    SATURDAY,   // 5
    SUNDAY      // 6
};

enum Color {
    RED = 1,    // Явное указание значения
    GREEN,      // 2
    BLUE = 5,   // 5
    YELLOW      // 6
};

int main() {
    Day today = WEDNESDAY;
    Color favoriteColor = BLUE;
    
    cout << "Сегодня: ";
    switch (today) {
        case MONDAY: cout << "Понедельник"; break;
        case TUESDAY: cout << "Вторник"; break;
        case WEDNESDAY: cout << "Среда"; break;
        case THURSDAY: cout << "Четверг"; break;
        case FRIDAY: cout << "Пятница"; break;
        case SATURDAY: cout << "Суббота"; break;
        case SUNDAY: cout << "Воскресенье"; break;
    }
    cout << endl;
    
    cout << "Любимый цвет имеет код: " << favoriteColor << endl;
    
    return 0;
}
```

## 5. Объединения (union)

**Объединение** - это специальный тип данных, который позволяет хранить разные типы данных в одной области памяти.

```cpp
#include <iostream>
using namespace std;

union Data {
    int intValue;
    double doubleValue;
    char charValue;
};

int main() {
    Data data;
    
    data.intValue = 65;
    cout << "intValue: " << data.intValue << endl;
    
    data.doubleValue = 3.14;
    cout << "doubleValue: " << data.doubleValue << endl;
    
    data.charValue = 'A';
    cout << "charValue: " << data.charValue << endl;
    
    // ВАЖНО: В объединении хранится только одно значение за раз!
    // Присвоение нового значения затирает предыдущее
    
    return 0;
}
```

## 6. Практический пример: Система управления студентами

```cpp
#include <iostream>
#include <string>
using namespace std;

const int MAX_STUDENTS = 100;

struct Date {
    int day;
    int month;
    int year;
};

struct Student {
    int id;
    string name;
    Date birthDate;
    double grades[5];  // Массив оценок
    double averageGrade;
};

// Функция для вычисления среднего балла
double calculateAverage(double grades[], int size) {
    double sum = 0;
    for (int i = 0; i < size; i++) {
        sum += grades[i];
    }
    return sum / size;
}

// Функция для вывода информации о студенте
void printStudent(const Student& student) {
    cout << "ID: " << student.id << endl;
    cout << "Имя: " << student.name << endl;
    cout << "Дата рождения: " << student.birthDate.day << "." 
         << student.birthDate.month << "." << student.birthDate.year << endl;
    cout << "Оценки: ";
    for (int i = 0; i < 5; i++) {
        cout << student.grades[i] << " ";
    }
    cout << endl;
    cout << "Средний балл: " << student.averageGrade << endl;
    cout << "-------------------" << endl;
}

int main() {
    Student students[MAX_STUDENTS];
    int studentCount = 0;
    
    // Добавление студентов
    students[studentCount] = {1, "Анна Иванова", {15, 5, 2000}, {4.5, 5.0, 4.0, 3.5, 5.0}};
    students[studentCount].averageGrade = calculateAverage(students[studentCount].grades, 5);
    studentCount++;
    
    students[studentCount] = {2, "Петр Сидоров", {20, 8, 1999}, {3.0, 4.0, 4.5, 3.5, 4.0}};
    students[studentCount].averageGrade = calculateAverage(students[studentCount].grades, 5);
    studentCount++;
    
    // Вывод всех студентов
    cout << "Список студентов:" << endl;
    for (int i = 0; i < studentCount; i++) {
        printStudent(students[i]);
    }
    
    // Поиск студента с наивысшим средним баллом
    int bestStudentIndex = 0;
    for (int i = 1; i < studentCount; i++) {
        if (students[i].averageGrade > students[bestStudentIndex].averageGrade) {
            bestStudentIndex = i;
        }
    }
    
    cout << "Лучший студент:" << endl;
    printStudent(students[bestStudentIndex]);
    
    return 0;
}
```

## 7. Важные замечания и лучшие практики

### 7.1. Размер массива и sizeof

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    cout << "Размер всего массива: " << sizeof(arr) << " байт" << endl;
    cout << "Размер одного элемента: " << sizeof(arr[0]) << " байт" << endl;
    cout << "Количество элементов: " << sizeof(arr) / sizeof(arr[0]) << endl;
    
    // Это полезно для циклов:
    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 7.2. Указатели и массивы

```cpp
#include <iostream>
using namespace std;

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    
    // Имя массива - это указатель на его первый элемент
    int* ptr = numbers;  // Эквивалентно: int* ptr = &numbers[0]
    
    cout << "numbers[0] = " << numbers[0] << endl;
    cout << "*ptr = " << *ptr << endl;
    
    // Арифметика указателей
    cout << "*(ptr + 1) = " << *(ptr + 1) << endl;  // numbers[1]
    cout << "*(ptr + 2) = " << *(ptr + 2) << endl;  // numbers[2]
    
    return 0;
}
```

## Заключение

**Ключевые моменты:**

1. **Массивы** - базовая структура для хранения последовательных данных одного типа
2. **Структуры** позволяют объединять данные разных типов
3. **Перечисления** делают код более читаемым
4. **Объединения** экономят память, но требуют осторожности

**Лучшие практики:**
- Всегда проверяйте границы массивов
- Используйте sizeof для определения размера массива
- Инициализируйте структуры при создании
- Используйте const с параметрами функций, когда не нужно изменять данные

Эти фундаментальные концепции являются основой для изучения более сложных структур данных в C++!
